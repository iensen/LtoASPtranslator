program(prog S P R) ::= sorts_keyw sort_defs(S) predicates_keyw pred_decls(P) rules_keyw rules(R)


sort_defs(sdefs S) ::= sort_def(S)
sort_defs(sdefs S cut_root(Ss)) ::= sort_def(S) sort_defs(Ss)

pred_decls(pdecls P) ::= pred_decl(P)
pred_decls(pdecls P cut_root(Ps)) ::= pred_decl(P) pred_decls(Ps)
pred_decl(pdecl I) ::= identifier(I) lparen rparen dot
pred_decl(pdecl I S) ::= identifier(I) lparen sort_names(S) rparen dot
sort_names(snames S) ::= sort_name(S)
sort_names(snames S cut_root(Ss)) ::= sort_name(S) comma sort_names(Ss)
sort_name(sname I) ::= pound identifier(I)

rules(rules R) ::= rule(R)
rules(rules R cut_root(Rs)) ::= rule(R) rules(Rs)


number(N) ::= numeral(N)
number(neg_num N) ::= minus numeral(N)

term(bt T) ::= basic_term(T)
term(T) ::= quantified_term(T)

basic_term(const C) ::= identifier(C)
basic_term(var V) ::= variable(V)
basic_term(num N) ::= number(N)
basic_term(T) ::= arithmetic_term(T)
basic_term(F) ::= functional_term(F)
basic_term(S) ::= sort_name(S)

ground_term(const C) ::= identifier(C)
ground_term(num N) ::= number(N)
ground_term(F) ::= ground_functional_term(F)
ground_term(F) ::= ground_arithmetic_term(F)

ground_functional_term(func I Args) ::= identifier(I) lparen ground_terms(Args) rparen
ground_terms(gterms T) ::= ground_term(T)
ground_terms(gterms T cut_root(Ts)) ::= ground_term(T) comma ground_terms(Ts)

arithmetic_term(ar_term T) ::= minus lparen T0(T) rparen
arithmetic_term(ar_term T) ::= minus T0(T)
arithmetic_term(ar_term T1 I T2) ::= lparen T0(T1) infix_1(I) T1(T2) rparen
arithmetic_term(ar_term T1 I T2) ::= lparen T1(T1) infix_2(I) T2(T2) rparen
arithmetic_term(ar_term T1 I T2) ::= T0(T1) infix_1(I) T1(T2)
arithmetic_term(ar_term T1 I T2) ::= T1(T1) infix_2(I) T2(T2)


ground_arithmetic_term(ar_term T) ::= minus lparen T0_g(T) rparen
ground_arithmetic_term(ar_term T) ::= minus T0_g(T)
ground_arithmetic_term(ar_term T1 I T2) ::= lparen T0_g(T1) infix_1(I) T1_g(T2) rparen
ground_arithmetic_term(ar_term T1 I T2) ::= lparen T1_g(T1) infix_2(I) T2_g(T2) rparen
ground_arithmetic_term(ar_term T1 I T2) ::= T0_g(T1) infix_1(I) T1_g(T2)
ground_arithmetic_term(ar_term T1 I T2) ::= T1_g(T1) infix_2(I) T2_g(T2)

infix_1(P) ::= plus(P)
infix_1(M) ::= minus(M)
infix_2(M) ::= mult(M)
infix_2(D) ::= div(D)
infix_2(M) ::= mod(M)
infix(I) ::= infix_1(I)
infix(I) ::= infix_2(I)


T0(T) ::= T1(T)
T0(sum T1 I T2) ::= T0(T1) infix_1(I) T1(T2)
T1(T) ::= T2(T)
T1(product T1 I T2) ::= T1 infix_2(I) T2
T2(T) ::= lparen T0(T) rparen
T2(V) ::= variable(V)
T2(tvar I V) ::= identifier(I) variable(V)
T2(N) ::= number(N)
T2(I) ::= identifier(I)


T0_g(T) ::= T1(T)
T0_g(sum T1 I T2) ::= T0_g(T1) infix_1(I) T1_g(T2)
T1_g(T) ::= T2_g(T)
T1_g(product T1 I T2) ::= T1_g(T1) infix_2(I) T2_g(T2)
T2_g(T) ::= lparen T0_g(T) rparen
T2_g(N) ::= number(N)
T2_g(I) ::= identifier(I)


quantifier(E) ::= every(E)
quantifier(A) ::= some(A)
functional_term(func I Args) ::= identifier(I) lparen terms(Args) rparen
basic_terms(bterms T) ::= basic_term(T)
basic_terms(bterms T cut_root(Ts)) ::= basic_term(T) comma basic_terms(Ts)

quantified_term(qt Q I V) ::= quantifier(Q) identifier(I) variable(V)
quantified_term(qt Q I) ::= quantifier(Q) identifier(I)

const_decl(cdecl C T) ::= const identifier(C) eq ground_arithmetic_term(T) dot
const_decl(cdecl C C1) ::= const identifier(C) eq identifier(C1) dot
const_decl(cdecl C N) ::= const identifier(C) eq number(N) dot

sort_def(sdef S E) ::= sort_name(S) eq set_expr(E) dot
set(set Ts) ::= lcurparen ground_terms(Ts) rcurparen


limit(I) ::= identifier(I)
limit(N) ::= number(N)
limit(A) ::= ground_arithmetic_term(A)
range(range L R) ::= limit(L) dot dot limit(R)
set_expr(S) ::= ST0(S)
set_constr(sconstr T) ::= basic_term(T)

ST0(S) ::= ST1(S)
ST0(union S1 S2) ::= ST0(S1) plus ST1(S2)
ST1(S) ::= ST2(S)
ST1(inters S1 S2) ::= ST1(S1) mult ST2(S2)
ST1(diff S1 S2) ::= ST1(S1) minus ST2(S2)
ST2(S) ::= lparen ST0(S) rparen
ST2(C) ::= set_constr(C)
ST2(R) ::= range(R)
ST2(S) ::= set(S)
ST2(S) ::= sort_name(S)

atom(S) ::= sort_atom(S)
atom(P) ::= predicate_atom(P)
atom(B) ::= build_in_atom(B)

sort_atom(satom S V) ::= sort_name(S) lparen variable(V) rparen

predicate_atom(patom I) ::= identifier(I)
predicate_atom(patom I Ts) ::= identifier(I) lparen terms(Ts) rparen

basic_predicate_atom(patom I) ::= identifier(I)
basic_predicate_atom(patom I Ts) ::= identifier(I) lparen basic_terms(Ts) rparen

build_in_atom(batom T1 O T2) ::= basic_term(T1) op(O) basic_term(T2)
op(O) ::= less(O)
op(O) ::= greater(O)
op(O) ::= lessoreq(O)
op(O) ::= greateroreq(O)
op(O) ::= noteq(O)
op(O) ::= eq(O)


s0(A) ::= atom(A)

s1(T) ::= s1a(T)
s1(T) ::= s1b(T)
s1(T) ::= s1c(T)
s1a(A) ::= s0(A)
s1b(neg_def A) ::= not s0(A)
s1c(neg_class A) ::= minus s0(A)

s2(T) ::= s2a(T)
s2(T) ::= s2b(T)
s2a(L) ::= s1(L)
s2b(conj L1 L2) ::= s2(L1) comma s1(L2)

s3(T) ::= s3a(T)
s3(T) ::= s3b(T)
s3a(T) ::= s2(T)
s3b(disj T1 T2) ::= s3(T1) bar s2(T2)


body(body B) ::= s3(B)


p_s0(A) ::= predicate_atom(A)
p_s0(S) ::= lparen p_s3(S) rparen
p_s1(A) ::= p_s0(A)
p_s1(neg_def A) ::= not p_s0(A)
p_s1(neg_class A) ::= minus p_s0(A)
p_s2(L) ::= p_s1(L)
p_s2(conj L1 L2) ::= p_s2(L1) comma p_s1(L2)
p_s3(T) ::= p_s2(T)
p_s3(disj T1 T2) ::= p_s3(T1) or p_s2(T2)
head(head H) ::= s3(H)


maybe_lit(mlit A) ::= maybe basic_predicate_atom(A)
bound(A) ::= arithmetic_term(A)
bound(I) ::= identifier(I)
bound(N) ::= number(N)


card_constr(cconst L A R) ::= bound(L) lessoreq bar lcurparen basic_predicate_atom(A) rcurparen bar lessoreq bound(R)

terms(terms T) ::= term(T)
terms(terms T cut_root(Ts)) ::= term(T) comma terms(Ts)

rule(constr B) ::= colon_hyphen body(B) dot
rule(fact H) ::= head(H) dot
rule(rule H B) ::= head(H) colon_hyphen body(B) dot
head(H) ::= maybe_lit(H)
head(H) ::= card_constr(H)
