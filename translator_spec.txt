L-ASP TRANSLATOR SPECIFICATION

The GitHub repository is:
https://github.com/iensen/LtoASPtranslator
The translator is src/translator.py

* ********** ********** ********** ********** ********** ********** **********
* DESCRIPTION
* ********** ********** ********** ********** ********** ********** **********

Given an L program, the translator produces a semantically equivalent ASP program.

Examples are located at: src/examples
(Look for pairs of .l and .sp files. Especially: ch5 and func_terms)

L spec is provided at:
https://github.com/iensen/LtoASPtranslator/blob/master/Lspec/Lspec.pdf
ASP manual is given here:
https://github.com/iensen/sparc/blob/master/User_Manual/Sparc_Manual.pdf

* ********** ********** ********** ********** ********** ********** **********
* MODULES
* ********** ********** ********** ********** ********** ********** **********

The translator has three primary modules: parser, transformer, and unparser. The control flow is:
    L program
        |
        |   parser
        |
        V
    parsed L program
        |
        |   transformer
        |
        V
    parsed ASP program
        |
        |   unparser
        |
        V
    ASP program
    
1. PARSER

This module parses an L program. The output is a list of parsed L statements, each of which represents either an L constant declaration, type declaration, or rule.

This L parser is introduced at:
https://github.com/iensen/LtoASPtranslator/blob/master/README.txt

The form of a parsed L program is described in the spec of a generic parser:
https://github.com/iensen/genparser/blob/master/docs/main/astgen.pdf
The L lexicon and grammar in use are located at:
https://github.com/iensen/LtoASPtranslator/tree/master/src

2. TRANSFORMER

From a parsed L program produced by the parser, the transformer outputs a parsed ASP program.

The form of a parsed ASP program is detailed at:
https://github.com/iensen/genparser/blob/master/docs/main/astgen.pdf
The ASP lexicon and grammar are here:
https://github.com/iensen/LtoASPtranslator/tree/master/src

The transformer has two secondary modules: rewriter and reassembler. The control flow is:
    parsed L program
        |
        |   rewriter
        |
        V
    incomplete parsed ASP program
        |
        |   reassembler
        |
        V
    parsed ASP program
    
2.1. REWRITER

An input of the rewriter is a parsed L program. This module rewrites an L [constant declaration / type declaration / rule] into an ASP [constant definition / sort definition / rule]. The output is an incomplete parsed ASP program.

This "ASP program" is incomplete because:

    (1)
        In L, ground terms in rules are unrequired to be members of declared types.
        But in ASP, such terms must be members of defined sorts.

    (2)
        L has no syntax for declaring predicates.
        Yet ASP requires such declarations.

(This lack will be remedied by the secondary module: reassembler.)

The rewriter has two tertiary modules: grounder and normalizer.

2.1.1. GROUNDER
The tertiary module 'grounder' converts quantified terms into grounded terms. For instance:
    From:
        type t1 = {a, b}.
        p1(every t1).
        p2(some t1).
    Into:
        p1(a) and p1(b).
        p2(a) or p2(b).

2.1.2. NORMALIZER
The tertiary module 'normalizer' converts a sentence into conjunctive/disjunctive normal form. For example:
    From:
        p1 and p2.
        q if r1 or r2.
    Into:
        p1. p2.
        q :- r1. q :- r2.

2.2. REASSEMBLER

The reassembler intakes an incomplete parsed ASP program from the rewriter. Then it outputs a parsed ASP program.

The reassembler remedies its incomplete "ASP program" input by:

    (1)
        Defining the sort #rule_gterms, whose members are ground terms extracted from rules.
        
    (2)
        Declaring predicates found in rules. In detail:
            
            (a)
                Define the sort #types, which is the union of defined sorts rewritten from declared types.
                
            (b)
                Define the sort #universal, which is the union of the sorts #types and #rule_gterms.
                
            (c)
                For instance, if a rule has a predicate p with arity 2, then declare it as: p(#universal, #universal).

3. UNPARSER

Given a parsed ASP program from the transformer, this module writes the corresponding ASP program.
