L-ASP TRANSLATOR SPECIFICATION

Given an L program, the translator produces a semantically equivalent ASP program.


########## ########## ########## ########## ########## ########## ########## ##########
MODULES

The translator has three primary modules: parser, transformer, and unparser. 
The control flow is:
    L program
        |
        |   parser
        |
        V
    parsed L program
        |
        |   transformer
        |
        V
    parsed ASP program
        |
        |   unparser
        |
        V
    ASP program
    

* ********** ********** ********** **********
* 1.        PARSER
* ********** ********** ********** **********

https://github.com/iensen/LtoASPtranslator/blob/master/docs/Lparser_guide.txt


* ********** ********** ********** **********
* 2.        TRANSFORMER
* ********** ********** ********** **********

From a parsed L program produced by the parser, 
the transformer gives a parsed ASP program.

The transformer has two secondary modules: rewriter and reassembler. The control flow is:
    parsed L program
        |
        |   rewriter
        |
        V
    incomplete parsed ASP program
        |
        |   reassembler
        |
        V
    parsed ASP program
    
    
* ********** ********** ********** 
* 2.1.      REWRITER
* ********** ********** ********** 

An input of the rewriter is a parsed L program. 
This secondary module rewrites an L [constant declaration / type declaration / rule] 
into an ASP [constant definition / sort definition / rule]. 
The output is an incomplete parsed ASP program.

This "ASP program" is incomplete because:
    (1) In L, ground terms in rules are unrequired to be members of declared types.
        But in ASP, such terms must be members of defined sorts.
    (2) L has no syntax for declaring predicates.
        Yet ASP requires such declarations.
This incompleteness will be remedied by the other secondary module: reassembler.

The rewriter has two tertiary modules: grounder and normalizer.


* ********** ********** 
* 2.1.1.    GROUNDER
* ********** ********** 

The tertiary module 'grounder' converts quantified terms into ground terms. 
For instance:
    From:
        type t1 = {a, b}.
        p1(every t1).
        p2(some t1).
    Into:
        p1(a) and p1(b).
        p2(a) or p2(b).


* ********** ********** 
* 2.1.2.    NORMALIZER
* ********** ********** 

The tertiary module 'normalizer' converts a sentence into 
conjunctive/disjunctive normal form. For example:
    From:
        p1, p2.         % But ASP disallows conjunction in a rule's head
        q :- r1 | r2.   % But ASP disallows disjunction in a rule's body
    Into:
        p1. p2.
        q :- r1. q :- r2.
        
        
* ********** ********** ********** 
* 2.2.      REASSEMBLER
* ********** ********** ********** 

This secondary module 'reassembler' intakes an incomplete parsed ASP program 
from the rewriter. 
Then the reassembler gives a parsed ASP program.

The reassembler remedies its incomplete "ASP program" input by:
    (1) Defining the sort #rule_gterms, 
        whose members are ground terms extracted from rules.
    (2) Declaring predicates found in rules. In detail:
        (a) Define the sort #types, 
            which is the union of defined sorts rewritten from declared types.
        (b) Define the sort #universal, 
            which is the union of the sorts #types and #rule_gterms.
        (c) For instance, if a rule has a predicate p with arity 2, 
            then declare: p(#universal, #universal).


* ********** ********** ********** **********
* 3.        UNPARSER
* ********** ********** ********** **********

Given a parsed ASP program from the transformer, 
this last primary module 'unparser' writes the corresponding ASP program.
